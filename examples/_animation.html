<!DOCTYPE html>
<html lang="en">
<head>
	<title>Multiple animated objects</title>
	<meta charset="utf-8">
	<meta content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" name="viewport">
	<link type="text/css" rel="stylesheet" href="main.css">
</head>
<body>
<div id="container"></div>

<script type="module">

	import * as THREE from '../build/three.module.js';

	import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
	import * as SkeletonUtils from './jsm/utils/SkeletonUtils.js';

	let worldScene = null;
	let renderer = null;
	let camera = null;
	let clock = null;
	let mixers = null;

	const model =
			{
				modelName: "Soldier", // Will use the 3D model from file models/gltf/Soldier.glb
				meshName: "vanguard_Mesh", // Name of the main mesh to animate
				position: {x: 0, y: 0, z: 0}, // Where to put the unit in the scene
				scale: 3, // Scaling of the unit. 1.0 means: use original size, 0.1 means "10 times smaller", etc.
				animationName: "Walk" // Name of animation to run
			};
	initScene();
	initRenderer();
	loadGltfModel(model, () =>instantiateUnits() )
	renderer.setAnimationLoop( animate );

	function loadGltfModel( model, onLoaded ) {
		const loader = new GLTFLoader();
		const modelName = "models/gltf/" + model.modelName + ".glb";

		loader.load( modelName, function ( gltf ) {
			const scene = gltf.scene;
			model.animations = gltf.animations;
			model.scene = scene;
			onLoaded();
		} );
	}

	function instantiateUnits() {
		const clonedScene = SkeletonUtils.clone( model.scene );
		if ( clonedScene ) {
			const clonedMesh = clonedScene.getObjectByName( model.meshName );
			if ( clonedMesh ) {
				//mixers = startAnimation( clonedMesh, model.animations, model.animationName );
				mixers = startCrossFadeAnimation( clonedMesh, model.animations, "Walk" , "Run" );
			}
			worldScene.add( clonedScene );
			if ( model.position ) {

				clonedScene.position.set( model.position.x, model.position.y, model.position.z );

			}
			if ( model.scale ) {

				clonedScene.scale.set( model.scale, model.scale, model.scale );

			}
		}
	}

	function startCrossFadeAnimation( skinnedMesh, animations, animationName,EndAnimationName  ) {
		const mixer = new THREE.AnimationMixer( skinnedMesh );
		const clip = THREE.AnimationClip.findByName( animations, animationName );
		const clipEnd = THREE.AnimationClip.findByName( animations, EndAnimationName );

		if ( clip && clipEnd ) {
			const action = mixer.clipAction( clip );
			const actionEnd = mixer.clipAction( clipEnd );
			action.crossFadeTo(actionEnd,3,true)
			action.play();
			actionEnd.play();
		}
		return mixer;
	}

	function startAnimation( skinnedMesh, animations, animationName ) {
		const mixer = new THREE.AnimationMixer( skinnedMesh );
		const clip = THREE.AnimationClip.findByName( animations, animationName );
		if ( clip ) {
			const action = mixer.clipAction( clip );
			action.play();
		}
		return mixer;
	}

	function animate() {
		// Get the time elapsed since the last frame
		const mixerUpdateDelta = clock.getDelta();
		if (mixers)
			mixers.update( mixerUpdateDelta );
		renderer.render( worldScene, camera );
	}

	function initRenderer() {
		const container = document.getElementById( 'container' );
		renderer = new THREE.WebGLRenderer( { antialias: true } );
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.outputEncoding = THREE.sRGBEncoding;
		container.appendChild( renderer.domElement );
	}

	function initScene() {

		camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
		camera.position.set( 3, 6, - 10 );
		camera.lookAt( 0, 1, 0 );

		clock = new THREE.Clock();

		worldScene = new THREE.Scene();
		worldScene.background = new THREE.Color( 0xa0a0a0 );

		const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444 );
		hemiLight.position.set( 0, 20, 0 );
		worldScene.add( hemiLight );


		// ground
		const groundMesh = new THREE.Mesh(
				new THREE.PlaneGeometry( 40, 40 ),
				new THREE.MeshPhongMaterial( {
					color: 0x999999,
					depthWrite: false
				} )
		);
		groundMesh.rotation.x = - Math.PI / 2;
		worldScene.add( groundMesh );
		window.addEventListener( 'resize', onWindowResize );
	}

	function onWindowResize() {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize( window.innerWidth, window.innerHeight );
	}


</script>

</body>

</html>