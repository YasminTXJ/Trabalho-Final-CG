<!DOCTYPE html>
<html lang="en">
<head>
	<title>Multiple animated objects</title>
	<meta charset="utf-8">
	<meta content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" name="viewport">
	<link type="text/css" rel="stylesheet" href="main.css">
</head>
<body>
<div id="container"></div>

<script type="module">

	import * as THREE from '../build/three.module.js';

	import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
	import * as SkeletonUtils from './jsm/utils/SkeletonUtils.js';

	let worldScene = null;
	let renderer = null;
	let camera = null;
	let clock = null;
	let mixers = null;

	const model =
			{
				modelName: "Soldier", // Will use the 3D model from file models/gltf/Soldier.glb
				meshName: "vanguard_Mesh", // Name of the main mesh to animate
				position: {x: 0, y: 0, z: 0}, // Where to put the unit in the scene
				scale: 3, // Scaling of the unit. 1.0 means: use original size, 0.1 means "10 times smaller", etc.
				animationName: "Idle" // Name of animation to run
			};
	initScene();
	initRender();
	loadGltfModel(model, () =>instantiateUnits() );
	renderer.setAnimationLoop( render );

	function loadGltfModel( model, onLoaded ) {
		const loader = new GLTFLoader();
		const modelName = "models/gltf/" + model.modelName + ".glb";
		loader.load( modelName, function ( gltf ) {
			const scene = gltf.scene;
			model.animations = gltf.animations;
			model.scene = scene;
			onLoaded();
		} );
	}

	function instantiateUnits() {
		const scene_skel= SkeletonUtils.clone(model.scene);
		if (scene_skel){
			const mesh_obj= scene_skel.getObjectByName(model.meshName);
			if (mesh_obj) {
				mixers = startAnimation(mesh_obj, model.animations, model.animationName);
				worldScene.add(scene_skel);
				scene_skel.position.set(model.position.x,model.position.y,model.position.z);
				scene_skel.scale.set(model.scale,model.scale,model.scale);
			}
		}
	}

	function startAnimation( skinnedMesh, animations, animationName ) {
		const mixer = new THREE.AnimationMixer(skinnedMesh);
		const clip = THREE.AnimationClip.findByName(animations,animationName);
		if (clip){
			const action = mixer.clipAction(clip);
			action.play();
		}
		return mixer;
	}
	function initScene(){
		camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
		camera.position.set( 3, 6, - 10 );
		camera.lookAt( 0, 1, 0 );
		clock = new THREE.Clock();
		worldScene = new THREE.Scene();
		worldScene.background = new THREE.Color( 0xa0a0a0 );
		const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444 );
		hemiLight.position.set( 0, 20, 0 );
		worldScene.add( hemiLight );
		// ground
		const groundMesh = new THREE.Mesh(
				new THREE.PlaneGeometry( 40, 40 ),
				new THREE.MeshPhongMaterial( {
					color: 0x999999,
					depthWrite: false
				} )
		);
		groundMesh.rotation.x = - Math.PI / 2;
		worldScene.add( groundMesh );
		window.addEventListener( 'resize', onWindowResize );
	}

	function onWindowResize() {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize( window.innerWidth, window.innerHeight );
	}

	function initRender(){
		const container = document.getElementById( 'container' );
		renderer = new THREE.WebGLRenderer( { antialias: true } );
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.outputEncoding = THREE.sRGBEncoding;
		container.appendChild( renderer.domElement );
	}

	function render(){
		const delta = clock.getDelta();
		if (mixers)
			mixers.update(delta);
		renderer.render( worldScene, camera );
	}







</script>

</body>

</html>