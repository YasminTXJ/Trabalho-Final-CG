<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Shader Customizado com Reflexo e Transparência</title>
</head>
<body>
  <script type="module">
    import * as THREE from '../build/three.module.js';
    import { OrbitControls } from './jsm/controls/OrbitControls.js';
    import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
    import { RGBELoader } from './jsm/loaders/RGBELoader.js';

    // =======================================================================
    // Shaders
    // =======================================================================


    const CustomCubeShader = {
      uniforms: {
        cubeTexture: { value: null } // Textura padrão para os cubos
      },
      vertexShader: `
        out vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        in vec2 vUv;
        uniform sampler2D cubeTexture;
        out vec4 outColor;
        void main() {
          outColor = texture(cubeTexture, vUv);
        }
      `
    };

    const CustomFresnelShader = {
      uniforms: {
        "mFresnelBias": { value: 0.1 },//Controla o mínimo de reflexão quando se olha direto para a superfície (ângulo reto).Quanto maior o bias, mais reflexo vai aparecer até mesmo em ângulos frontais.
        "mFresnelPower": { value: 1.0 },//Controla como rápido o reflexo aumenta com o ângulo de visão
        "mFresnelScale": { value: 0.8 },//Escala o quanto o efeito de Fresnel influencia na reflexão.
        "transparency": { value: 2.0 },
        "transparentTexture": { value: null },
        "reflectedTexture": { value: null },
        "planeTexture": { value: null },
        "sceneTexture": { value: null },// Nova textura para a cena atrás do plano
        "refractionRatio": { value: 1.0 / 1.31 } // Índice de refração (ar/água = 1.0/1.33)
      },
      vertexShader: `
        out vec2 vUv;
        out float vReflectionFactor;
        uniform float mFresnelBias;
        uniform float mFresnelPower;
        uniform float mFresnelScale;
        uniform float refractionRatio; // Índice de refração
        out vec3 vWorldPosition;
        out vec3 vNormal;
        out vec2 refractedUv;
        out vec4 projected;
        void main() {
          vUv = uv;
          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
          vec4 worldPosition = modelMatrix * vec4(position, 1.0);
          vWorldPosition = worldPosition.xyz;
          vec3 I = worldPosition.xyz - cameraPosition;
          vNormal = normalize(mat3(modelMatrix) * normal);
          vReflectionFactor = mFresnelBias + mFresnelScale * pow(1.0 + dot(normalize(I), vNormal), mFresnelPower);
          gl_Position = projectionMatrix * mvPosition;

          // Vetor refratado
          vec3 refracted = refract(I, vNormal, refractionRatio);

          // Vetor de refração (direção do raio que atravessa o plano)
          vec3 refractDir = normalize(refract(I, vNormal, refractionRatio));

          // Ponto estimado de onde o raio refratado vai atingir "atrás" do plano
          vec3 refractedPoint = vWorldPosition + refractDir * 5.0; // o '5.0' é um fator de profundidade, pode ajustar

          // Projeta o ponto no espaço de tela
          projected = projectionMatrix * viewMatrix * vec4(refractedPoint, 1.0);

        }
      `,
      fragmentShader: `
        uniform sampler2D transparentTexture;
        uniform sampler2D reflectedTexture;
        uniform sampler2D planeTexture;
        uniform sampler2D sceneTexture;
        uniform float transparency;

        in vec2 vUv;
        in float vReflectionFactor;
        in vec3 vWorldPosition;
        in vec3 vNormal;
        in vec4 projected;

        out vec4 fragColor;

        void main() {
          if (vWorldPosition.y < -2.0) discard;

          vec2 refractedUv = projected.xy / projected.w * 0.5 + 0.5;
          
          // Sample textures
          vec4 transColor = texture(transparentTexture, refractedUv);
          vec4 reflColor = texture(reflectedTexture, vec2(1.0 - refractedUv.x, refractedUv.y));
          vec4 planeTexColor = texture(planeTexture, vUv);
          vec4 behindColor = texture(sceneTexture, refractedUv);

          // Mistura de refração (cena atrás) com transparência da textura base
          vec4 refractionMix = mix(transColor, behindColor, 0.4); // % da cena refratada

          vec4 fresnelMix = mix(refractionMix, reflColor, vReflectionFactor);

          vec4 finalColor = mix(fresnelMix, planeTexColor, 0.3); // % textura da superfície
          // Aplicar transparência
          finalColor.a *= transparency;

          fragColor = finalColor;
        }
      `
    };

    // =======================================================================
    // Inicialização da cena e renderização
    // =======================================================================
    let scene, camera, renderer, controls,cube1,cube2;
    let dividingPlane;
    let transparentRT, reflectedRT, behindPlaneRT;
    let clipPlaneTransparent, clipPlaneReflected;


    function init() {
      // Inicialização do renderer com WebGL
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.localClippingEnabled = true;
      document.body.appendChild(renderer.domElement);

      // Criação da cena e câmera
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 2, 10);
      controls = new OrbitControls(camera, renderer.domElement);

      // Adiciona uma textura de ambiente
      const ambientTextureLoader = new THREE.CubeTextureLoader();
      ambientTextureLoader.setPath('./textures/cube/Park2/');
      const ambientTexture = ambientTextureLoader.load([
        "posx.jpg", "negx.jpg",
        "posy.jpg", "negy.jpg",
        "posz.jpg", "negz.jpg"
      ]);
      scene.background = ambientTexture;
      // light

				const ambientLight = new THREE.AmbientLight( 0xcccccc, 0.4 );
				scene.add( ambientLight );

				const directionalLight = new THREE.DirectionalLight( 0xffffff, 0.6 );
				directionalLight.position.set( - 1, 1, 1 );
				scene.add( directionalLight );



      const textureLoader = new THREE.TextureLoader();

      // Criação dos cubos
      const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
      const cubeMaterial = new THREE.ShaderMaterial({
        uniforms: {
          cubeTexture: { value: textureLoader.load('./textures/cube/Carbon.png') }
        },
        vertexShader: CustomCubeShader.vertexShader,
        fragmentShader: CustomCubeShader.fragmentShader,
        glslVersion: THREE.GLSL3,
        clipping: true
      });

      cube1 = new THREE.Mesh(cubeGeometry, cubeMaterial);
      cube1.position.set(-4, 0, 0);
      scene.add(cube1);

      cube2 = new THREE.Mesh(cubeGeometry, cubeMaterial);
      cube2.position.set(4, 0, 0);
      scene.add(cube2);

      // Render targets
      transparentRT = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: THREE.RGBAFormat
      });

      reflectedRT = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: THREE.RGBAFormat
      });

      behindPlaneRT = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: THREE.RGBAFormat
      });

      // Clipping planes
      clipPlaneTransparent = new THREE.Plane(new THREE.Vector3(1, 0, 0), 0.2);
      clipPlaneReflected = new THREE.Plane(new THREE.Vector3(-1, 0,0), 0.3);

      // Plano divisor
      const planeGeometry = new THREE.PlaneGeometry(6, 6);
      const fresnelUniforms = THREE.UniformsUtils.clone(CustomFresnelShader.uniforms);
      const planeTexture = textureLoader.load('./textures/Ice/ice-texture.jpg');
      fresnelUniforms.planeTexture.value = planeTexture;

      const fresnelMaterial = new THREE.ShaderMaterial({
        uniforms: fresnelUniforms,
        vertexShader: CustomFresnelShader.vertexShader,
        fragmentShader: CustomFresnelShader.fragmentShader,
        transparent: true,
        glslVersion: THREE.GLSL3
      });

      dividingPlane = new THREE.Mesh(planeGeometry, fresnelMaterial);
      dividingPlane.position.set(0, 0, 0);
      dividingPlane.rotation.y = Math.PI / 2;
      dividingPlane.renderOrder = 1;
      scene.add(dividingPlane);

      window.addEventListener('resize', onWindowResize, false);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      transparentRT.setSize(window.innerWidth, window.innerHeight);
      reflectedRT.setSize(window.innerWidth, window.innerHeight);
      behindPlaneRT.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      cube2.rotation.x += 0.01;
      cube2.rotation.y += 0.01;
      // Primeiro passe: renderiza cena transparente
      dividingPlane.visible = false;
      renderer.clippingPlanes = [clipPlaneTransparent];
      renderer.setRenderTarget(transparentRT);
      renderer.clear();
      renderer.render(scene, camera);

      // Segundo passe: renderiza cena refletida
      //renderer.clear();
      renderer.clippingPlanes = [clipPlaneReflected];
      renderer.setRenderTarget(reflectedRT);
      renderer.clear();
      renderer.render(scene, camera);

      // Terceiro passe: renderiza cena atrás do plano
      
      renderer.setRenderTarget(behindPlaneRT);
      renderer.clear();
      renderer.render(scene, camera);
      dividingPlane.visible = true;

      // Quarto passe: renderiza cena final
      renderer.setRenderTarget(null);
      renderer.clippingPlanes = [];
      dividingPlane.material.uniforms.transparentTexture.value = transparentRT.texture;
      dividingPlane.material.uniforms.reflectedTexture.value = reflectedRT.texture;
      dividingPlane.material.uniforms.sceneTexture.value = behindPlaneRT.texture;
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>